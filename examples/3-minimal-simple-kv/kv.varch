event key of string;
event value of int;

protocol p_kv = ยง{
    l_get: !key?value.;
    l_put: !tuple<key,value>?bool.;
};

(* TODO 
1) add redis support
2) add grpc + consol
3) multi jvm
4) sharding
*)

component KVServer {
    onstartup (bridge<Client, KVServer, p_kv> b){
        print(">>> Starting a KVServer instance");
        bind(this.p_in, b);
    }

    inport p_in :: bridge<Client, KVServer, p_kv> expecting (dual p_kv) = this.callback;

    result<void, error> callback (blabel msg, (dual p_kv) s) {
        print("callback");

        branch s on msg {
            | l_get => s_i -> { 
                print("l_get");
                tuple<key, !value.> tmp = receive(s_i);
                fire(tmp._1, value(42))?;
                (* jedis fire(tmp._1, this.get(tmp._0))?;*)
            }
            | l_put => s_i -> {
                print("l_put");
                tuple<tuple<key,value>, !bool.> tmp = receive(s_i);
                tuple<key, value> res = tmp._0; 
                (* jedis this.put(res._0, res._1);*)
                fire(tmp._1, true)?;
            }
        }

        return ok(());
    }

    (*** Impl of get and put out of the scope of the glu, i.e., defined as abstract methods ***)
    value get(key k){
        return value(this._get(k));
    }
    int _get(key k);
    bool put(key k, value v); 
}

component Client {
    activation_ref<KVServer> kv;

    outport p_out expecting p_kv;

    onstartup (bridge<Client, KVServer, p_kv> b, activation_ref<KVServer> kv){
        print(">>> Starting a Client instance");
        bind(this.p_out, b);
        this.kv = kv;
        
        this.put(key("Key1"), value(10));
        this.get(key("Key1"));
    }

    result<void, error> get(key k){
        session<p_kv> s = initiate_session_with(this.p_out, this.kv);

        !key?value. s = select(s, l_get)?;
        ?value. s = fire(s, k)?;

        (* We need this intermediate let since there is no unification yet for universal type and receive is universally quantified *)
        (* TODO maybe use polyapp *)
        tuple<value, .> tmp = receive(s);
        value tmp_ret = tmp._0;
        int ret = tmp_ret._0_;
        
        (* TODO print(f">> get success {{ret}}");*)
        print(">> get success");
        print(int_to_string(ret));
        print("");
        return ();//TODO current recv-elim can not return :')
    }

    result<void, error> put(key k, value v){
        print(">> start put");
        session<p_kv> s = initiate_session_with(this.p_out, this.kv);

        !tuple<key, value>?bool. s = select(s, l_put)?;
        ?bool. s = fire(s, (k, v))?;
        print(">> end put");

        (*assert(receive(s, this.b)._0);*) //TODO assert do not exit
    }
}
component TopLevel {
    onstartup () {
        print(">> Entering toplevel");
        bridge<Client, KVServer, p_kv> b = bridge(p_kv);

        activation_ref<KVServer> kv_a = spawn KVServer(b);
        activation_ref<Client> c = spawn Client(b, kv_a);
        print(">> Ending toplevel");
    }
}