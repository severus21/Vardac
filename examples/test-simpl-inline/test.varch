protocol p = !int?int.;

component A {
    onstartup (){
        debug("A > init");
        this.methoda();
    }

    void methoda(){
        debug("A > methoda");
    }
}

(* Make B inlinable in A*)
@inline_in([A])
component B {
    inport p_in :: bridge<C, B, inline p> expecting (dual p) = this.callback;
    onstartup (bridge<C, B, inline p> chan){
        debug("B > init");
        bind(this.p_in, chan);
        this.methodb();
    }

    void methodb(){
        debug("B > methodb");
    }

    void callback(int i, ?int. st_cont){
        string msg = int_to_string(i);
        debug("B > callback "+msg);
        fire(st_cont, 21);
    }
}

component C {
    outport p_out expecting (inline p);
    inport p_in :: bridge<C, B, inline p> expecting (?int.) = this.callback;
    onstartup (bridge<C, B, p> chan, activation_ref<B> b){
        bind(this.p_out, chan);
        bind(this.p_in, chan);
        session<p> s0 = initiate_session_with(this.p_out, b);
        fire(s0, 42);
    }
    
    void callback(int i, . st_cont){
        string msg = int_to_string(i);
        debug("C > callback "+msg);
    }
}

component TopLevel {
    component Inner { (*spawn in can not be used in guardian directly, since we need to generate ports and so on*)
        onstartup (){
            bridge<C,B, inline p> chan = bridge(p);
            activation_ref<A> a = spawn A();
            activation_ref<B> b = spawn B(chan) in a;
            activation_ref<C> c = spawn C(chan, b);
        }
    }

    onstartup (){
        spawn Inner();
    }
}