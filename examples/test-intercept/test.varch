event ping of;
event pong of;

protocol p_pingpong = !ping?pong.;

(********************* PingPong *********************)
@capturable([MsgCounter])
component A {
    onstartup (bridge<B, A, inline p_pingpong> chan){
        print("> Starting A");
        bind(this.p_in, chan);
    }

    inport p_in :: bridge<B, A, inline p_pingpong> expecting (dual p_pingpong) = this.handle_ping;

    result<void, error> handle_ping (ping msg, !pong. s1) {
        print("ping");
        fire(s1, pong())?; 
    }
}

component B {
    outport p_out expecting (inline p_pingpong);

    onstartup (bridge<B, A, inline p_pingpong> chan, activation_ref<A> b) {
        bind(this.p_out, chan);
        this.methodb(b);
    }

    result<void, error> methodb(activation_ref<A> b){
        print("> Starting B");
        session<p_pingpong> s0 = initiate_session_with(this.p_out, b);

        ?pong. s1 = fire(s0, ping())?;
        print("> Ping fired");
        tuple<pong, !ping!ping.> res = receive(s1);
        print("pong_or_timeout");
    }
}


    (* Orchestration logic *)
component PingPong {
    (* FIXME TODO specialized MsgCounter is not subtype of MsgCounter in Java,
        HOT FIX replace MsgCounter by Any
    *)
    activation_ref<any> make_interceptor (
        option<place> -> activation_ref<any> factory,
        string intercepted_component_schema,
        place p_of_intercepted
    ){
        place p = current_place();
        return factory(some(p));
    }

    onstartup () {
        bridge<B, A, inline p_pingpong> bridge0 = bridge(p_pingpong);

        (* First group *) 
        with<MsgCounter> this.make_interceptor{
            activation_ref<A> a = spawn A(bridge0);
        }
        activation_ref<B> b = spawn B(bridge0, a);

        (* Second group *) 
        with<MsgCounter, anonymous> this.make_interceptor{
            activation_ref<A> aa = spawn A(bridge0);
        }
        activation_ref<B> bb = spawn B(bridge0, aa);

        (* Third group - TODO low-level api *)
    }
}
(********************* Interception logic *********************)

(*
    TODO write a msg counter - independent of msg
*)
component MsgCounter {
    int nbr_msg = 0;
    onstartup () {
        print(">MsgCounter"); (* count ping *)
    }

    (****************************** Programmer defined state and state handling ******************************)
    void incr(){
        this.nbr_msg = this.nbr_msg + 1;
    }

    (****************************** Activation onboarding ******************************)
    @onboard([A]) (* List of schemas that can be onboarded by the method *)
    bool onboard_A(activation_ref<A> a, place p_of_a){
        return true;
    }

    (****************************** Session interception  ******************************)
    @sessioninterceptor(true, both)
    option<activation_ref<A>> my_session_interceptor_a(
        dict<activation_id, activation_ref<A>> onboarded_activations, 
        activation_ref<B> from, 
        bridge<B, A, inline p_pingpong> b_inner, 
        string requested_to_schema, 
        ping msg
    ){
        (*  assert onboarded_activations > 1 
            since this do not create activations to process request
        *)
        activation_ref<A> a = pick(onboarded_activations);
        return some(a);
    }

    @sessioninterceptor(false, both)
    option<activation_ref<A>> my_session_interceptor_b(
        dict<activation_id, activation_ref<A>> onboarded_activations, 
        activation_ref<B> from, 
        bridge<B, A, inline p_pingpong> b_inner, 
        activation_ref<A> requested_to, 
        ping msg
    ){
        return some(requested_to);
    }

    (****************************** Msg interception  ******************************)
    (* TODO need polymorphism *)
    @msginterceptor(both)
    option<ping> intercept_ping(
        activation_ref<A> from, 
        activation_ref<B> to, 
        ?pong. continuation_in, 
        !pong. continuation_out, 
        ping msg
    ){
        this.incr();
        
        print("Counted ping");
        print(this.nbr_msg);

        return some(msg);
    }
}


(********************* Guardians and entry points *********************)

component Orchestrator {
    onstartup () {
        spawn PingPong();
    }
}

void titia (array<string> args){
    print("Main");
}
